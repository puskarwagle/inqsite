#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const PROJECT_ROOT = path.join(__dirname, '..');
const COMPONENTS_DIR = path.join(PROJECT_ROOT, 'src/lib/components');
const OUTPUT_DIR = path.join(PROJECT_ROOT, 'static/content');
const ROUTES_DIR = path.join(PROJECT_ROOT, 'src/routes');
const REGISTRY_FILE = path.join(OUTPUT_DIR, '_registry.json');

// Shared components that appear on all pages
const SHARED_COMPONENTS = ['Header', 'Footer'];

/**
 * Detect which page a component belongs to based on its folder/name
 */
function detectPage(componentName, componentFolder) {
	// Shared components
	if (SHARED_COMPONENTS.includes(componentName)) {
		return null; // null means it's shared across all pages
	}

	// Map folder names to routes
	const folderToRoute = {
		'home': '/',
		'about': '/aboutus',
		'team': '/team',
		'contact': '/contact',
		'pricing': '/pricing-one',
		'service-one': '/service-one',
		'service-two': '/service-two',
		'home-one': '/home-one',
		'home-two': '/home-two',
		'shared': null // shared components
	};

	if (componentFolder && folderToRoute[componentFolder]) {
		return folderToRoute[componentFolder];
	}

	// Fallback: detect from component name prefix
	if (componentName.startsWith('Home')) return '/';
	if (componentName.startsWith('About')) return '/aboutus';
	if (componentName.startsWith('Team')) return '/team';
	if (componentName.startsWith('Contact')) return '/contact';
	if (componentName.startsWith('Pricing')) return '/pricing-one';
	if (componentName.startsWith('ServiceOne')) return '/service-one';
	if (componentName.startsWith('ServiceTwo')) return '/service-two';

	return '/'; // default to home
}

/**
 * Load or create registry
 */
function loadRegistry() {
	if (fs.existsSync(REGISTRY_FILE)) {
		return JSON.parse(fs.readFileSync(REGISTRY_FILE, 'utf-8'));
	}
	return {
		pages: {},
		sharedComponents: SHARED_COMPONENTS,
		lastUpdated: new Date().toISOString()
	};
}

/**
 * Save registry
 */
function saveRegistry(registry) {
	registry.lastUpdated = new Date().toISOString();
	fs.writeFileSync(REGISTRY_FILE, JSON.stringify(registry, null, 2));
}

/**
 * Update registry with new component
 */
function updateRegistry(componentName, page) {
	const registry = loadRegistry();

	if (page === null) {
		// Shared component
		if (!registry.sharedComponents.includes(componentName)) {
			registry.sharedComponents.push(componentName);
		}
	} else {
		// Page-specific component
		if (!registry.pages[page]) {
			registry.pages[page] = [];
		}
		if (!registry.pages[page].includes(componentName)) {
			registry.pages[page].push(componentName);
		}
	}

	saveRegistry(registry);
	return registry;
}

/**
 * Generate +page.server.js for a route
 */
function generateServerFile(route, components) {
	const routePath = route === '/' ? '' : route;
	const serverFilePath = path.join(ROUTES_DIR, routePath, '+page.server.js');

	// Ensure directory exists
	const dir = path.dirname(serverFilePath);
	if (!fs.existsSync(dir)) {
		fs.mkdirSync(dir, { recursive: true });
	}

	// Generate code
	const componentLoads = components.map(comp => {
		return `\t\t${comp}: JSON.parse(fs.readFileSync(path.join(contentDir, '${comp}.json'), 'utf-8'))`;
	}).join(',\n');

	const code = `import fs from 'fs';
import path from 'path';

// Auto-generated by extract-content.js
// Components: ${components.join(', ')}

export async function load() {
\tconst contentDir = path.join(process.cwd(), 'static', 'content');

\ttry {
\t\treturn {
\t\t\tcontent: {
${componentLoads}
\t\t\t}
\t\t};
\t} catch (error) {
\t\tconsole.error('Error loading content:', error);
\t\treturn { content: {} };
\t}
}
`;

	fs.writeFileSync(serverFilePath, code);
	console.log(`   ‚úì Generated: ${serverFilePath}`);
}

/**
 * Generate semantic key names based on content
 */
function generateSemanticKey(text, tag, counter, context = '') {
	const cleaned = text.toLowerCase().replace(/[^a-z0-9\s]/g, '').trim();
	const words = cleaned.split(/\s+/).filter(w => w.length > 0);

	if (words.length === 0) return `${tag}_${counter}`;

	const keyWords = words.slice(0, 3).join('_');

	if (context) return `${context}_${keyWords}`;

	// Common patterns
	if (tag === 'h1') return 'hero_heading';
	if (tag === 'h2' && counter === 1) return 'section_heading';
	if (tag === 'h3' && counter === 1) return 'subsection_heading';

	if (words.includes('get') && words.includes('started')) return 'button_get_started';
	if (words.includes('watch') && words.includes('video')) return 'button_watch_video';
	if (words.includes('learn') && words.includes('more')) return 'button_learn_more';
	if (words.includes('contact')) return 'button_contact';
	if (words.includes('read') && words.includes('more')) return 'link_read_more';

	return keyWords || `${tag}_${counter}`;
}

/**
 * Check if text looks like a counter/animation number
 */
function isCounterNumber(text) {
	if (/^[0-9]$/.test(text)) return true;
	if (/^[0-9]+[KM%]?$/.test(text) && text.length <= 4) return true;
	return false;
}

/**
 * Detect if a component is already integrated with CMS
 */
function isIntegratedComponent(html) {
	// Check for the integration markers
	const hasContentProp = html.includes('export let content');
	const hasGetTextHelper = html.includes('getText') && html.includes('fallback');
	return hasContentProp && hasGetTextHelper;
}

/**
 * Extract content from integrated component (has getText/getImage/getLink)
 * This extracts the fallback values from the template patterns
 */
function extractFromIntegratedComponent(html, componentName) {
	const content = {
		componentName,
		lastModified: new Date().toISOString(),
		texts: {},
		images: {},
		links: {}
	};

	console.log(`   ‚Üí Detected integrated component, extracting fallback values...`);

	// Extract getText patterns: {getText('key', 'fallback value')} or alt={getText('key', 'fallback')}
	const getTextRegex = /\{?getText\(['"]([^'"]+)['"]\s*,\s*['"]([^'"]*)['"]\)\}?/g;
	let match;
	while ((match = getTextRegex.exec(html)) !== null) {
		const key = match[1];
		const value = match[2];
		if (value && !isCounterNumber(value)) {
			content.texts[key] = value;
		}
	}

	// Extract getImage patterns for URLs: getImage('key').url || 'fallback'
	const getImageUrlRegex = /getImage\(['"]([^'"]+)['"]\)\.url\s*\|\|\s*['"](.*?)['"]/g;
	while ((match = getImageUrlRegex.exec(html)) !== null) {
		const key = match[1];
		const url = match[2];
		if (!content.images[key]) {
			content.images[key] = {};
		}
		content.images[key].url = url;
	}

	// Extract getImage patterns for alt text: getImage('key').alt || 'fallback'
	const getImageAltRegex = /getImage\(['"]([^'"]+)['"]\)\.alt\s*\|\|\s*['"](.*?)['"]/g;
	while ((match = getImageAltRegex.exec(html)) !== null) {
		const key = match[1];
		const alt = match[2];
		if (!content.images[key]) {
			content.images[key] = {};
		}
		content.images[key].alt = alt;
	}

	// Extract getLink patterns for href: getLink('key').href || 'fallback'
	const getLinkHrefRegex = /getLink\(['"]([^'"]+)['"]\)\.href\s*\|\|\s*['"](.*?)['"]/g;
	while ((match = getLinkHrefRegex.exec(html)) !== null) {
		const key = match[1];
		const href = match[2];
		if (!content.links[key]) {
			content.links[key] = {};
		}
		content.links[key].href = href;
	}

	// Extract getLink patterns for text: {getLink('key').text || 'fallback'}
	const getLinkTextRegex = /\{?getLink\(['"]([^'"]+)['"]\)\.text\s*\|\|\s*['"](.*?)['"]\}?/g;
	while ((match = getLinkTextRegex.exec(html)) !== null) {
		const key = match[1];
		const text = match[2];
		if (!content.links[key]) {
			content.links[key] = {};
		}
		content.links[key].text = text;
	}

	return content;
}

/**
 * Validate extracted content doesn't contain template literals
 */
function validateExtractedContent(content) {
	const errors = [];

	// Check texts
	for (const [key, value] of Object.entries(content.texts || {})) {
		if (typeof value === 'string' && (value.includes('{getText') || value.includes('{getImage') || value.includes('{getLink'))) {
			errors.push(`Text key "${key}" contains template literal: ${value.substring(0, 50)}...`);
		}
	}

	// Check images
	for (const [key, img] of Object.entries(content.images || {})) {
		if (img.url && img.url.includes('{getImage')) {
			errors.push(`Image key "${key}" URL contains template literal`);
		}
		if (img.alt && img.alt.includes('{getImage')) {
			errors.push(`Image key "${key}" alt contains template literal`);
		}
	}

	// Check links
	for (const [key, link] of Object.entries(content.links || {})) {
		if (link.href && link.href.includes('{getLink')) {
			errors.push(`Link key "${key}" href contains template literal`);
		}
		if (link.text && link.text.includes('{getLink')) {
			errors.push(`Link key "${key}" text contains template literal`);
		}
	}

	return errors;
}

/**
 * Extract text content from HTML string
 */
function extractTextContent(html, componentName) {
	const content = {
		componentName,
		lastModified: new Date().toISOString(),
		texts: {},
		images: {},
		links: {}
	};

	const seenTexts = new Set();

	// Extract headings
	const headingRegex = /<(h[1-6])[^>]*>(.*?)<\/\1>/gis;
	let match;
	const headingCounters = { h1: 1, h2: 1, h3: 1, h4: 1, h5: 1, h6: 1 };

	while ((match = headingRegex.exec(html)) !== null) {
		const tag = match[1];
		const text = match[2].replace(/<[^>]+>/g, '').replace(/\s+/g, ' ').trim();

		if (text && text.length > 0 && !seenTexts.has(text) && !isCounterNumber(text)) {
			const key = generateSemanticKey(text, tag, headingCounters[tag]);
			content.texts[key] = text;
			headingCounters[tag]++;
			seenTexts.add(text);
		}
	}

	// Extract paragraphs
	const paragraphRegex = /<p[^>]*>(.*?)<\/p>/gis;
	let pCounter = 1;
	while ((match = paragraphRegex.exec(html)) !== null) {
		const text = match[1].replace(/<[^>]+>/g, '').replace(/\s+/g, ' ').trim();

		if (text && text.length > 0 && !seenTexts.has(text) && !isCounterNumber(text)) {
			const key = generateSemanticKey(text, 'paragraph', pCounter);
			content.texts[key] = text;
			pCounter++;
			seenTexts.add(text);
		}
	}

	// Extract button text
	const buttonRegex = /<(?:button|a)[^>]*class="[^"]*(?:button|btn)[^"]*"[^>]*>(.*?)<\/(?:button|a)>/gis;
	let btnCounter = 1;
	while ((match = buttonRegex.exec(html)) !== null) {
		const text = match[1].replace(/<[^>]+>/g, '').replace(/\s+/g, ' ').trim();

		if (text && text.length > 0 && !seenTexts.has(text) && !isCounterNumber(text)) {
			const key = generateSemanticKey(text, 'button', btnCounter);
			content.texts[key] = text;
			btnCounter++;
			seenTexts.add(text);
		}
	}

	// Extract meaningful div text
	const divRegex = /<div[^>]*class="[^"]*(?:rt-text-style|rt-button-text|rt-dropdown-link|rt-menu-font|rt-contact-text)[^"]*"[^>]*>(.*?)<\/div>/gis;
	let divCounter = 1;
	while ((match = divRegex.exec(html)) !== null) {
		const text = match[1].replace(/<[^>]+>/g, '').replace(/\s+/g, ' ').trim();

		if (text && text.length > 0 && !seenTexts.has(text) && !isCounterNumber(text)) {
			const key = generateSemanticKey(text, 'text', divCounter);
			content.texts[key] = text;
			divCounter++;
			seenTexts.add(text);
		}
	}

	// Extract images
	const imageRegex = /<img[^>]*src=["']([^"']+)["'][^>]*(?:alt=["']([^"']+)["'])?[^>]*>/gi;
	const seenImages = new Set();
	let imageCounter = 1;

	while ((match = imageRegex.exec(html)) !== null) {
		const url = match[1];
		const alt = match[2] || '';

		if (seenImages.has(url)) continue;
		seenImages.add(url);

		let key = `image_${imageCounter}`;
		if (alt) {
			const altKey = alt.toLowerCase().replace(/[^a-z0-9]/g, '_').substring(0, 30);
			key = altKey || key;
		}

		content.images[key] = { url, alt };
		imageCounter++;
	}

	// Extract links
	const linkRegex = /<a[^>]*href=["']([^"']+)["'][^>]*>(.*?)<\/a>/gis;
	const seenLinks = new Set();
	let linkCounter = 1;

	while ((match = linkRegex.exec(html)) !== null) {
		const href = match[1];
		const rawText = match[2];

		const text = rawText
			.replace(/<(?:img|svg|div|span)[^>]*>.*?<\/(?:img|svg|div|span)>/gis, '')
			.replace(/<[^>]+>/g, ' ')
			.replace(/\s+/g, ' ')
			.trim();

		if (!text || text.length < 2 || seenLinks.has(href)) continue;
		seenLinks.add(href);

		if (href !== '#') {
			let key = generateSemanticKey(text, 'link', linkCounter);

			if (href.includes('mailto:')) key = 'email_link';
			else if (href.includes('tel:')) key = 'phone_link';
			else if (href.includes('facebook')) key = 'social_facebook';
			else if (href.includes('twitter') || href.includes('x.com')) key = 'social_twitter';
			else if (href.includes('linkedin')) key = 'social_linkedin';
			else if (href.includes('instagram')) key = 'social_instagram';
			else if (text.toLowerCase().includes('home')) key = 'link_home';
			else if (text.toLowerCase().includes('about')) key = 'link_about';
			else if (text.toLowerCase().includes('contact')) key = 'link_contact';
			else if (text.toLowerCase().includes('service')) key = 'link_service';

			content.links[key] = { href, text };
			linkCounter++;
		}
	}

	return content;
}

/**
 * Process a single component file
 */
function processComponent(componentPath, componentName, componentFolder) {
	console.log(`\nüìÑ Processing: ${componentName}`);

	const html = fs.readFileSync(componentPath, 'utf-8');

	// Detect extraction mode
	let content;
	if (isIntegratedComponent(html)) {
		// Use template pattern extraction for integrated components
		content = extractFromIntegratedComponent(html, componentName);
	} else {
		// Use HTML extraction for non-integrated components
		console.log(`   ‚Üí Non-integrated component, extracting from HTML...`);
		content = extractTextContent(html, componentName);
	}

	// Validate extracted content
	const validationErrors = validateExtractedContent(content);
	if (validationErrors.length > 0) {
		console.error(`   ‚ö†Ô∏è  Validation warnings for ${componentName}:`);
		validationErrors.forEach(error => console.error(`      - ${error}`));
	}

	// Count extracted items
	const textCount = Object.keys(content.texts).length;
	const imageCount = Object.keys(content.images).length;
	const linkCount = Object.keys(content.links).length;

	console.log(`   ‚úì Extracted ${textCount} texts, ${imageCount} images, ${linkCount} links`);

	// Write JSON file
	const outputPath = path.join(OUTPUT_DIR, `${componentName}.json`);
	fs.writeFileSync(outputPath, JSON.stringify(content, null, 2));
	console.log(`   ‚úì Saved to ${outputPath}`);

	// Detect page and update registry
	const page = detectPage(componentName, componentFolder);
	updateRegistry(componentName, page);
	console.log(`   ‚úì Registered to: ${page || 'SHARED'}`);

	return { componentName, content, page, folder: componentFolder };
}

/**
 * Main execution
 */
function main() {
	const args = process.argv.slice(2);

	console.log('üöÄ Enhanced Content Extraction Script\n');

	// Ensure output directory exists
	if (!fs.existsSync(OUTPUT_DIR)) {
		fs.mkdirSync(OUTPUT_DIR, { recursive: true });
	}

	if (args.length === 0) {
		console.log('‚ùå Please specify components to extract.');
		console.log('Usage: node extract-content.js <component1> <component2> ...');
		console.log('Example: node extract-content.js HomeA Footer AboutA TeamA');
		process.exit(1);
	}

	const results = [];

	// Process each component
	for (const componentName of args) {
		const possiblePaths = [
			{ path: path.join(COMPONENTS_DIR, 'home', `${componentName}.svelte`), folder: 'home' },
			{ path: path.join(COMPONENTS_DIR, 'shared', `${componentName}.svelte`), folder: 'shared' },
			{ path: path.join(COMPONENTS_DIR, 'about', `${componentName}.svelte`), folder: 'about' },
			{ path: path.join(COMPONENTS_DIR, 'team', `${componentName}.svelte`), folder: 'team' },
			{ path: path.join(COMPONENTS_DIR, 'contact', `${componentName}.svelte`), folder: 'contact' },
			{ path: path.join(COMPONENTS_DIR, 'pricing', `${componentName}.svelte`), folder: 'pricing' },
			{ path: path.join(COMPONENTS_DIR, 'service-one', `${componentName}.svelte`), folder: 'service-one' },
			{ path: path.join(COMPONENTS_DIR, 'service-two', `${componentName}.svelte`), folder: 'service-two' },
			{ path: path.join(COMPONENTS_DIR, 'home-one', `${componentName}.svelte`), folder: 'home-one' },
			{ path: path.join(COMPONENTS_DIR, 'home-two', `${componentName}.svelte`), folder: 'home-two' }
		];

		let found = false;
		for (const { path: componentPath, folder } of possiblePaths) {
			if (fs.existsSync(componentPath)) {
				const result = processComponent(componentPath, componentName, folder);
				results.push(result);
				found = true;
				break;
			}
		}

		if (!found) {
			console.log(`\n‚ö†Ô∏è  Component not found: ${componentName}`);
		}
	}

	// Generate server files for each page
	console.log('\nüì¶ Generating server load files...\n');
	const registry = loadRegistry();

	for (const [route, components] of Object.entries(registry.pages)) {
		// Add shared components to each page
		const allComponents = [...components, ...registry.sharedComponents];
		generateServerFile(route, allComponents);
	}

	console.log('\n‚úÖ Extraction complete!\n');
	console.log('üìä Summary:');
	results.forEach(({ componentName, content }) => {
		const total = Object.keys(content.texts).length +
		              Object.keys(content.images).length +
		              Object.keys(content.links).length;
		console.log(`   ${componentName}: ${total} editable items`);
	});
	console.log(`\nüìÇ Files saved to:`);
	console.log(`   - JSON: static/content/`);
	console.log(`   - Registry: static/content/_registry.json`);
	console.log(`   - Server files: src/routes/*/+page.server.js\n`);
}

main();
